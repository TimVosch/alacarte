> [!CAUTION]
> The following readme is mostly generated by AI, it is representable of the project, but might contain a few issues.
> The readme will be updated later when this little library has proven itself more.

# Ã€ la carte ðŸ¥ž

**Ã€ la carte** is a flexible Go data mapper that allows you to selectively fetch exactly the data you needâ€”fields and relationshipsâ€”from your SQL database and shape it into your Go structs.

It is designed to give you precise control over your data fetching, helping you avoid over-fetching and the N+1 query problem without the overhead of a full-featured ORM. The philosophy is simple: you order exactly what you want, Ã  la carte.

## Features

  * **Type-Safe Generic Models**: Uses Go generics (`alacarte.NewModel[T]`) for type-safe model definitions.
  * **Selective Field Loading**: Choose exactly which columns to load for any given query with a simple `Select()` call.
  * **Powerful Relational Mapping**: Define and eager-load `HasMany` relationships with batch queries to prevent the N+1 problem.
  * **Nested Selection & Resolution**: Use intuitive dot-notation (e.g., `"user.posts.comments.id"`) to select and resolve fields deep within your data model.
  * **Custom Data Transformation**: Scan one or more columns to temporary variables, before transforming and setting it on your domain model.
  * **Composable & Agnostic**: Built to be flexible. The relational query modifiers allow you to integrate with your favorite query builder, like [Squirrel](https://github.com/Masterminds/squirrel).

## Installation

```sh
go get pollex.nl/alacarte
```

## Usage

### Basic Model: Defining a Model and Selecting Fields

First, define your Go struct. `alacarte` will map database columns to its fields.

```go
// The target struct to hold our data.
type Author struct {
    ID   uint64
    Name string
    Tags []string
}
```

Next, create a `Model` that defines this mapping. You specify how each database column corresponds to a struct field pointer. For more complex types, like turning a comma-separated string into a slice, you can provide a custom transformation `Action`.

```go
// Create a new model for the Author struct, mapping to the "authors" table.
authorModel := alacarte.NewModel[Author]("authors").
    // Map the "id" column to the Author.ID field.
    AddField(
        "id",
        alacarte.Col("id"),
        alacarte.Ptr(func(t *Author) any { return &t.ID }),
    ).
    // Or use a simple mapping, which is a shortcut for the above.
    AddSimpleField("name", func(t *Author) any { return &t.Name }).
    // Map the "tags" column to a temporary string, then split it into the Author.Tags slice.
    // This is great for custom data processing.
    AddField(
        "tags",
        alacarte.Col("tags"),
        func(t *Author) (alacarte.Ptrs, alacarte.Action) {
            var tagString string
            return alacarte.Ptrs{&tagString}, func() {
                t.Tags = strings.Split(tagString, ",")
            }
        },
    )
```

Now, you can use your model to fetch and shape data. With `Select()`, you specify only the fields you need for this particular query. `alacarte` handles the rest.

```go
// Select only the "id" and "tags" fields for each author.
// The "name" field will not be populated.
authors, err := authorModel.Select("id", "tags").Collect(ctx, db)

// SELECT id, tags FROM authors;

// authors is now a []Author, with only the ID and Tags fields populated.
// authors[i].Name will be empty for all i.
```

-----

### Relational Models: Eager Loading Relationships

`alacarte` excels at loading relationships efficiently. Imagine an author who has many books, and each book has many comments.

```go
// Your Go structs with relationships
type Author struct {
	ID    uint64
	Name  string
	Books []Book 
}

type Book struct {
	ID       uint64
	Name     string
	AuthorID uint64
	Comments []Comment 
}

type Comment struct {
	ID     uint64
	Name   string
	BookID uint64
}
```

You define models for each struct and then link them with `AddRelation`. A relation definition specifies:

1.  The related model (e.g., a `Book` has many `Comment`s).
2.  How to link parent and child objects in Go (`BindBy`).
3.  How to modify the database query to fetch all children for a batch of parents at once (the `QueryMod`).

```go
// Define the model for books
bookModel := alacarte.NewModel[Book]("books").
    AddField("id", alacarte.Col("id"), alacarte.Ptr(func(t *Book) any { return &t.ID })).
    AddField("name", alacarte.Col("name"), alacarte.Ptr(func(t *Book) any { return &t.Name })).
    AddField("author_id", alacarte.Col("author_id"), alacarte.Ptr(func(t *Book) any { return &t.AuthorID })).
    // Add a "has-many" relation to comments
    AddRelation("comments",
        alacarte.HasMany(
            // The comments model
            commentModel,
            // Defines a "Binder" which maps each comment to the parent.
            alacarte.BindBy(
                func(book Book, comment Comment) bool { return comment.BookID == book.ID },
                func(book *Book, comments []Comment) { book.Comments = comments },
            ),
            // Modifies the query to fetch all comments for a slice of books in one go
            func(books []Book) alacarte.QueryMod {
                return func(q alacarte.Q, table string) alacarte.Q {
                    ids := lo.Map(books, func(book Book, _ int) uint64 { return book.ID })
                    return q.Where(squirrel.Eq{"book_comments.book_id": ids})
                }
            },
        ),
    )

// Define the model for authors, which has a relation to books
authorModel := alacarte.NewModel[Author]("authors").
    AddField("id", alacarte.Col("id"), alacarte.Ptr(func(t *Author) any { return &t.ID })).
    AddField("name", alacarte.Col("name"), alacarte.Ptr(func(t *Author) any { return &t.Name })).
    // Add a "has-many" relation to books
    AddRelation("books", alacarte.HasMany(bookModel, ...)) // Similar definition as above
```

With the relational models defined, you can write a single, expressive query to fetch an entire nested data structure.

  - `Select()` lets you pick fields from nested relations using dot-notation.
  - `Resolve()` tells `alacarte` to eager-load the specified relationships.

```go
// Fetch authors and resolve their books and the comments on those books.
authors, err := authorModel.
    // Select specific fields, including from nested relations.
    Select(
        "id", "name", 
        "books.id", "books.name", "books.author_id", 
        "books.comments.id", "books.comments.name",
    ).
    // Eager-load the 'books' relation and the nested 'books.comments' relation.
    Resolve("books", "books.comments").
    Collect(context.Background(), db)

// The result is a fully populated []Author slice with nested books and comments, in 3 queries:
//     SELECT authors.id, authors.name FROM authors
//     SELECT books.author_id, books.id, books.name FROM books WHERE books.author_id IN ('1','2')
//     SELECT book_comments.book_id, book_comments.id, book_comments.name FROM book_comments WHERE book_comments.book_id IN ('1','2','3','4')
```

# TODOs

- [ ] Automatically add required fields for Relation binding
    currently, the fields `id` and `books.author_id` must be in Select(...) for the .Resolve(...) to work.
- [ ] Probably many bugs, so more tests would be great
- [ ] Spent time on optimizations
- [ ] Improve API for simple fields and relations
